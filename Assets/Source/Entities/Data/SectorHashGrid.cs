using Assets.Source.Extensions;
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

namespace Assets.Source.Entities.Data
{
    /// <summary>
    /// HashGrid for a sector
    /// </summary>
    public class SectorHashGrid
    {
        public SectorHashGrid(double cellSize)
        {
            CellSize = cellSize;
        }

        /// <summary>
        /// Cell dictonary map. The key  of the dictonary is generated by calling <see cref="GetCellKey(Vector2)"/>
        /// </summary>
        public Dictionary<string, SectorHashGridCell> CellDict { get; private set; } = new();

        /// <summary>
        /// A set of all cells in this hash grid.
        /// </summary>
        public HashSet<SectorHashGridCell> CellSet { get; private set; } = new();

        /// <summary>
        /// The length and height of each cell in this hash grid.
        /// </summary>
        public double CellSize { get; private set; }

        /// <summary>
        /// The total number of <see cref="SectorHashGridClient"/> in this hash grid
        /// </summary>
        public int ClientCount { get; private set; } = 0;

        public Sector Sector
        {
            get
            {
                return GameObject.FindObjectsOfType<Sector>().First((s) => s.hashgrid.Equals(this));
            }
        }

        /// <summary>
        /// An unique string representation for a <see cref="SectorHashGridCell"/> in this hash grid according to its position
        /// </summary>
        /// <param name="cellposition">The position of the cell</param>
        /// <returns>Returns x and y values of <paramref name="cellposition"/> seperated by a comma with no white spaces e.g. "2,3" </returns>
        public static string GetCellKey(Vector2 cellposition)
        {
            return cellposition.x + "," + cellposition.y;
        }

        /// <summary>
        /// Creates a <see cref="SectorHashGridClient"/> and registers it in this hash grid
        /// </summary>
        /// <param name="source">The entity the client will be part of</param>
        /// <returns>The the created client</returns>
        public SectorHashGridClient CreateClient(MapEntity source)
        {
            var client = new SectorHashGridClient
            {
                source = source,
                grid = this
            };

            InsertClient(client);

            return client;
        }

        /// <summary>
        /// Gets all cells in a radius <paramref name="r"/>in the origin <paramref name="origin"/>
        /// </summary>
        /// <param name="origin">The world positoin representation of the radius origin </param>
        /// <param name="r">The lenght of the radius</param>
        /// <returns>
        /// For each cell, calculates a ray from <paramref name="origin"/> to the cell of length <paramref name="r"/>.
        /// If the ray's tip is inside the bounderies of the cell, returns that cell.
        /// </returns>
        public HashSet<SectorHashGridCell> FindCellsInRadius(Vector2 origin, double r)
        {
            HashSet<SectorHashGridCell> filtered = new();

            foreach (var cell in CellSet)
            {
                var direction = (cell.position - origin).normalized;
                var distance = (cell.position - origin).magnitude;

                var speed = Math.Min(distance, r);

                var position = origin + (direction * (float)speed);

                var xleft = cell.position.x - (cell.size.x / 2);
                var xright = cell.position.x + (cell.size.x / 2);

                var yleft = cell.position.y - (cell.size.y / 2);
                var yright = cell.position.y + (cell.size.y / 2);

                if (position.x.IsInRange(xleft, xright) && position.y.IsInRange(yleft, yright))
                {
                    filtered.Add(cell);
                }
            }

            return filtered;
        }

        /// <summary>
        /// Finds all <see cref="SectorHashGridClient"/> inside the radius <paramref name="r"/> from <paramref name="origin"/>
        /// </summary>
        /// <param name="origin">The origin of the radius in world position</param>
        /// <param name="r">The length of the radius</param>
        /// <returns>
        /// First, it calculates each cell in the range of radius by using the <seealso cref="FindCellsInRadius(Vector2, double)"/> method.
        /// For each client in these cells, if the <see cref="Vector3.sqrMagnitude"/> of the client position minus <paramref name="origin"/> is lesser or equal to <paramref name="r"/> ^ 2, returns that client.
        /// </returns>
        public HashSet<SectorHashGridClient> FindClientsInRadius(Vector2 origin, double r)
        {
            HashSet<SectorHashGridClient> clients = new();

            Vector3 v3 = origin;
            var filteredCells = FindCellsInRadius(origin, r);
            if (filteredCells.Count == 0) return clients;

            foreach (var cell in filteredCells)
            {
                foreach (var client in cell.clients)
                {
                    if ((client.source.transform.position - v3).sqrMagnitude <= r * r)
                    {
                        clients.Add(client);
                    }
                }
            }
            return clients;
        }

        /// <summary>
        /// Adds a client to this hash grid
        /// </summary>
        /// <param name="client"></param>
        /// <remarks>
        /// This method is useful for scenarios <see cref="MapEntity"/> are temporary disabled
        /// </remarks>
        public void InsertClient(SectorHashGridClient client)
        {
            var cellpos = WorldPositionToCellPosition(client.source.transform.position);

            SectorHashGridCell cell = FindOrCreateCell(cellpos);
            cell.clients.Add(client);
            client.cell = cell;
            ClientCount++;
        }

        /// <summary>
        /// Removes a client from the hash grid. It is recommended to use this method when the <see cref="MapEntity"/> is disabled or destroyed
        /// </summary>
        /// <param name="client"></param>
        public void RemoveClient(SectorHashGridClient client)
        {
            var clicell = client.cell;

            if (CellSet.TryGetValue(clicell, out var cell))
            {
                cell.clients.Remove(client);
                if (cell.clients.Count == 0)
                {
                    DeRegisterCell(cell);
                }
                ClientCount--;
            }
        }

        /// <summary>
        /// Updates a client's data in the hash grid.
        /// If the client has changed cells, removes the old cell from the grid if it doesn't have clients.
        /// </summary>
        /// <param name="client"></param>
        /// <remarks>
        /// It's recommended to call this method only when the client has moved.
        /// </remarks>
        public void UpdateClient(SectorHashGridClient client)
        {
            var currentkey = GetCellKey(client.source.transform.position);
            var oldkey = client.cell.Key;

            if (currentkey != oldkey)
            {
                RemoveClient(client);
                InsertClient(client);
            }
        }

        /// <summary>
        /// Removes a cell from <see cref="CellDict"/> and <see cref="CellSet"/>
        /// </summary>
        /// <param name="cell"></param>
        private void DeRegisterCell(SectorHashGridCell cell)
        {
            CellDict.Remove(cell.Key);
            CellSet.Remove(cell);
        }

        /// <summary>
        /// Finds the Cell in the <paramref name="cellpos"/> position. If the cell doesn't exist, it creates one.
        /// </summary>
        /// <param name="cellpos">The position of the cell in world position</param>
        /// <returns>The found or created cell</returns>
        private SectorHashGridCell FindOrCreateCell(Vector2 cellpos)
        {
            var key = GetCellKey(cellpos);

            if (CellDict.TryGetValue(key, out SectorHashGridCell cell))
            {
                return cell;
            }
            else
            {
                cell = new SectorHashGridCell
                {
                    position = cellpos,
                    size = new Vector2((float)CellSize, (float)CellSize)
                };

                RegisterCell(cell);
            }

            return cell;
        }

        /// <summary>
        /// Adds a cell to <see cref="CellDict"/> and <see cref="CellSet"/>
        /// </summary>
        /// <param name="cell"></param>
        private void RegisterCell(SectorHashGridCell cell)
        {
            CellDict.Add(cell.Key, cell);
            CellSet.Add(cell);
        }

        /// <summary>
        /// Calculates the cell position given a world position
        /// </summary>
        /// <param name="worldPosition"></param>
        /// <returns>
        /// For the x axis, returns the closest number to <paramref name="worldPosition"/>.x that is divisable by <see cref="CellSize"/>.
        /// This same process is done for the y axis as well.
        /// </returns>
        private Vector2 WorldPositionToCellPosition(Vector3 worldPosition)
        {
            double quotientX = NumberExtensions.ClosestNumberDivisableByM(worldPosition.x, CellSize);
            double quotientY = NumberExtensions.ClosestNumberDivisableByM(worldPosition.y, CellSize);

            return new((float)quotientX, (float)quotientY);
        }
    }
}